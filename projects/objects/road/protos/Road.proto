#VRML_SIM R2021b utf8
# license: Copyright Cyberbotics Ltd. Licensed for use only with Webots.
# license url: https://cyberbotics.com/webots_assets_license
# A fully customizable road, the number of lanes, the dimensions and the path of the road is configurable.
# For each line separating two lanes it is possible to configure if this one is continuous or dashed.
# B-Spline can be used in order to interpolate the path of the road and an optional border can be enable.
# The boundingObject of each border and the road itself can be independently enable or disable.
# This model was sponsored by the CTI project RO2IVSim (http://transport.epfl.ch/simulator-for-mobile-robots-and-intelligent-vehicles).
# template language: javascript

PROTO Road [
  field        SFVec3f              translation               0 0 0
  field        SFRotation           rotation                  0 1 0 0
  field        SFString             name                      "road"                  # Optionally defines the street name.
  field        SFString             id                        ""                      # Optionally defines a unique ID. A unique ID is required to use the SUMO exporter.
  field        SFString             startJunction             ""                      # Optionally defines a reference to the Crossroad connected at the first Road waypoint. Setting correctly this field is required to use the SUMO exporter.
  field        SFString             endJunction               ""                      # Optionally defines a reference to the Crossroad connected at the last Road waypoint. Setting correctly this field is required to use the SUMO exporter.
  field        SFFloat              width                     7                       # Defines the total width of the road (excluding sidewalk).
  field        SFInt32              numberOfLanes             2                       # Defines the number of lanes (used for the texture mapping).
  field        SFInt32              numberOfForwardLanes      1                       # Defines the number of forward lanes. (this is an information with no impact on the graphical shape).
  field        SFFloat              speedLimit                -1.0                    # Optionally defines the speed limit. The recommended unit is meter per seconds.
  field        MFNode{RoadLine {}}  lines                     [ RoadLine { } ]        # Defines the property of each line separating two lanes.
  field        SFFloat              roadBorderHeight          0.15                    # Defines the height of the sidewalk.
  field        MFFloat              roadBorderWidth           [ 0.8 ]                 # Defines the width of the sidewalk associated to each way-point (if there are less values than way-points, the last value is used for the last remaining way-points).
  field        SFBool               road                      TRUE                    # Defines the width of the sidewalk associated to each way-point (if there are less values than way-points, the last value is used for the last remaining way-points).
  field        SFBool               rightBorder               TRUE                    # Defines whether the road should have a right sidewalk.
  field        SFBool               leftBorder                TRUE                    # Defines whether the road should have a left sidewalk.
  field        SFBool               rightBarrier              FALSE                   # Defines whether the road should have a right barrier.
  field        SFBool               leftBarrier               FALSE                   # Defines whether the road should have a left barrier.
  field        SFBool               bottom                    FALSE                   # Defines whether the road bottom should be displayed (useful in case of bridge).
  field        MFVec3f              wayPoints                 [ 0 0 0, 0 0 1 ]        # Defines the path of the road.
  field        MFFloat              roadTilt                  [ 0, 0]                 # Defines the tilting angle corresponding to each way-point (if there are less values than way-points, 0 is used for the last remaining way-points).
  field        MFFloat              startingAngle             []                      # Optionally defines the angle of the road at the first way-point.
  field        MFFloat              endingAngle               []                      # Optionally defines the angle of the road at the lasst way-point.
  field        MFString             startLine                 []                      # Optionally defines the texture used for the road line at the first way-point for each lane. If the string is empty, no road line will be added for the corresponding lane. The two textures `textures/road_line_dashed.png` and `textures/road_line_triangle.png` may be used in this field.
  field        MFString             endLine                   []                      # Optionally defines the texture used for the road line at the last way-point for each lane. If the string is empty, no road line will be added for the corresponding lane.
  field        SFInt32              splineSubdivision         4                       # Defines the degree of interpolation using B-Splines (if the value is lower than 0, the interpolation is disabled).
  field        SFNode               appearance                Asphalt { }             # Defines the appearance of the road.
  field        SFNode               pavementAppearance        Pavement { }            # Defines the appearance of the sidewalk.
  field        MFString             bottomTexture             []                      # Defines the texture to be used for the bottom of the road.
  field        SFString             turnLanesForward          ""                      # Defines painted arrows before the end of the lanes using the same format as the OSM "turn:lanes:forward" key (e.g. "through|left;through|none"). Please refer to the corresponding OSM tag: http://wiki.openstreetmap.org/wiki/Key:turn.
  field        SFString             turnLanesBackward         ""                      # Same as `turnLanesForward` but for the OSM "turn:lanes:backward" key.
  field        SFBool               locked                    TRUE                    # Is `Solid.locked`.
  field        SFBool               roadBoundingObject        FALSE                   # Defines whether the road should have a bounding object.
  field        SFBool               rightBorderBoundingObject FALSE                   # Defines whether the right sidewalk should have a bounding object.
  field        SFBool               leftBorderBoundingObject  FALSE                   # Defines whether the left sidewalk should have a bounding object.
  field        SFBool               rightBarrierBoundingObject TRUE                   # Defines whether the right crash barrier (if any) should have a bounding object.
  field        SFBool               leftBarrierBoundingObject TRUE                    # Defines whether the left crash barrier (if any) should have a bounding object.
  field        SFBool               castShadows               FALSE                   # Defines whether the road should cast shadows.
  field        SFString             contactMaterial           "default"               # Is `Solid.contactMaterial`.

  hiddenField  MFBool               dashedLine          TRUE                          # Deprecated in Webots R2018c.
]
{
  %{
    import * as wbgeometry from 'modules/webots/wbgeometry.js';
    import * as wbvector2 from 'modules/webots/wbvector2.js';
    import * as wbvector3 from 'modules/webots/wbvector3.js';

    // fields checks
    let width = fields.width.value;
    if (width <= 0.0) {
      width = fields.width.defaultValue;
      console.error('\'width\' must be strictly positive. Value reset to ' + width + '.');
    }

    const barrierOffset = 0.06 + 0.05 * width;
    let numberOfLanes = fields.numberOfLanes.value;
    if (numberOfLanes < 1) {
      numberOfLanes = fields.numberOfLanes.defaultValue;
      console.error('\'numberOfLanes\' must be greater or equal to 1. Value reset to ' + numberOfLanes + '.');
    }
    let borderHeight = fields.roadBorderHeight.value;
    let borderWidth = fields.roadBorderWidth.value;
    let nbBorderWidthPoint = borderWidth.length;

    for (let j = 0; j < nbBorderWidthPoint; ++j) {
      if (borderWidth[j] < 0) {
        borderWidth[j] = 0;
        console.error('\'roadBorderWidth\' elements must be positive. Value reset to ' + borderWidth[j] + '.');
      }
    }

    let roadLines = fields.lines.value;
    for (let i = 0; i < roadLines.length; ++i) {
      if (roadLines[i].node_name !== 'RoadLine') {
        roadLines[i] = undefined;
        console.error('Only \'RoadLine\' nodes should be added in the \'lines\' field.');
      }
    }

    let textureCoordinateRatio = 0.2;
    let defaultLineWidth = 0.075;
    let heightOffset  = 0.01;
    let dashedLine    = fields.dashedLine.value;
    let rightBorder   = fields.rightBorder.value;
    let leftBorder    = fields.leftBorder.value;
    let rightBarrier  = fields.rightBarrier.value;
    let leftBarrier   = fields.leftBarrier.value;
    let bottom        = fields.bottom.value;
    let road          = fields.road.value;
    let roadBO        = fields.roadBoundingObject.value;
    let rightBorderBO = fields.rightBorderBoundingObject.value;
    let leftBorderBO  = fields.leftBorderBoundingObject.value;
    let startingAngle = fields.startingAngle.value;
    let endingAngle   = fields.endingAngle.value;
    let startLine     = fields.startLine.value;
    let endLine       = fields.endLine.value;
    let bottomTexture = fields.bottomTexture.value;
    let useBottomTexture = false;
    if (bottomTexture.length > 0)
      useBottomTexture = true;

    let nbStartLine = startLine.length;
    let nbEndLine   = endLine.length;
    if (nbStartLine > numberOfLanes)
      nbStartLine = numberOfLanes;
    if (nbEndLine > numberOfLanes)
      nbEndLine = numberOfLanes;

    let wayPoints = fields.wayPoints.value;
    let nbWayPoint = wayPoints.length;

    let borderWidthOriginal = [];
    if (nbBorderWidthPoint > 0) {
      for (let j = 1, j <= nbWayPoint + 1; ++j) {
        if (borderWidth[j] === undefined)
          borderWidthOriginal[j] = borderWidthOriginal[j - 1];
        else
          borderWidthOriginal[j] = borderWidth[j];
      }
    }

    let originalTilt = fields.roadTilt.value;
    for (let j = 0; j < nbWayPoint; ++j) {
      if (originalTilt[j] === undefined)
        originalTilt[j] = 0;
    }
    originalTilt[nbWayPoint] = originalTilt[nbWayPoint - 1];

    let splineSubdivision = fields.splineSubdivision.value;
    // use B-Spline interpolation if splineSubdivision is greater than 1
    if (splineSubdivision > 0)
      wayPoints = wbgeometry.bSpline3(wayPoints, splineSubdivision);

    nbWayPoint = wayPoints.length;

    let tilt = [];
    if (splineSubdivision > 1) {
      for (let j = 0; j < nbWayPoint; ++j) {
        let ratio = (j % splineSubdivision) / splineSubdivision;
        let index = Math.floor(j/splineSubdivision); // TODO: ERROR HERE?
        tilt[j] = originalTilt[index] * (1 - ratio) + originalTilt[index + 1] * ratio;
        if (nbBorderWidthPoint > 0)
          borderWidth[j] = borderWidthOriginal[index] * (1 - ratio) + borderWidthOriginal[index + 1] * ratio;
      }
    } else {
      if (nbBorderWidthPoint > 0)
        borderWidth = borderWidthOriginal;

      tilt = originalTilt;
    }

    let angle = []
    let distance = [0];
    for (let i = 0; i <= nbWayPoint - 1; ++i) {
      // compute angle for each way-points
      if ((i === nbWayPoint - 1 || i >= (nbWayPoint - 1 - splineSubdivision)) && endingAngle[0] !== undefined) {
        // last segment with ending angle set
        // we use third order Spline approximation,
        // therefore we want to adapt the angle of the road with a cubic ratio between last and second last way-points
        let ratio = 0;
        if (splineSubdivision > 0)
          ratio = Math.pow(((nbWayPoint - 1 - i)  / splineSubdivision), 3);

        if (i === 0)
          angle[i] = endingAngle[0] * (1 - ratio) - wbvector2.angle({x: wayPoints[i+2].x, y: wayPoints[i+2].z}, {x: wayPoints[i+1].x, y: wayPoints[i+1].z}) * ratio;
        else
          angle[i] = endingAngle[0] * (1 - ratio) - wbvector2.angle({x: wayPoints[i+1].x, y: wayPoints[i+1].z}, {x: wayPoints[i].x, y: wayPoints[i].z}) * ratio;
      } else if (i > 0 && i > splineSubdivision) {
        // all the segments except first
        if (i === nbWayPoint - 1)
          angle[i] = -wbvector2.angle({x: wayPoints[i+1].x, y: wayPoints[i+1].z}, {x: wayPoints[i].x, y: wayPoints[i].z});
        else
          angle[i] = -wbvector2.angle({x: wayPoints[i+2].x, y: wayPoints[i+2].z}, {x: wayPoints[i].x, y: wayPoints[i].z});
      } else if (startingAngle[0] !== undefined) {
        // first segment with starting angle set
        let ratio = 0;
        if (splineSubdivision > 0)
          ratio = Math.pow((i / splineSubdivision), 3);

        if (i === nbWayPoint - 1)
          angle[i] = startingAngle[0] * (1 - ratio) - wbvector2.angle({x: wayPoints[i+1].x, y: wayPoints[i+1].z}, {x: wayPoints[i].x, y: wayPoints[i].z}) * ratio;
        else
          angle[i] = startingAngle[0] * (1 - ratio) - wbvector2.angle({x: wayPoints[i+2].x, y: wayPoints[i+2].z}, {x: wayPoints[i+1].x, y: wayPoints[i+1].z}) * ratio;
      } else {
        // first segment if starting angle is not set
        if (i === nbWayPoint - 1)
          angle[i] = -wbvector2.angle({x: wayPoints[i+1].x, y: wayPoints[i+1].z}, {x: wayPoints[i].x, y: wayPoints[i].z});
        else
          angle[i] = -wbvector2.angle({x: wayPoints[i+2].x, y: wayPoints[i+2].z}, {x: wayPoints[i+1].x, y: wayPoints[i+1].z});
      }

      // compute distance (from beginning of road) for each way-points
      if (i !== 0)
        distance[i] = distance[i-1] + wbvector3.distance(wayPoints[i+1], wayPoints[i]);
    }
  }%
  Solid {
    translation IS translation
    rotation IS rotation
    name IS name
    model "road"
    children [
      Group {
        children IS lines
      }
      # road
      %{ if road then }%
        DEF ROAD Solid {
          children [
            Shape {
              appearance IS appearance
              geometry DEF ROAD_GEOMETRY IndexedFaceSet {
                coord Coordinate {
                  point [
                    %{ for i = 0, nbWayPoint - 1 do }%
                      %{= wayPoints[i+1].x - 0.5 * math.cos(angle[i]) * width }% %{= wayPoints[i+1].y - 0.5 * math.sin(tilt[i+1]) * width }% %{= wayPoints[i+1].z - 0.5 * math.sin(angle[i]) * width }%
                      %{= wayPoints[i+1].x + 0.5 * math.cos(angle[i]) * width }% %{= wayPoints[i+1].y + 0.5 * math.sin(tilt[i+1]) * width }% %{= wayPoints[i+1].z + 0.5 * math.sin(angle[i]) * width }%
                    %{ end }%
                  ]
                }
                texCoord TextureCoordinate {
                  point [
                    %{ for i = 0, nbWayPoint - 1 do }%
                      %{= -0.5 * width * textureCoordinateRatio }% %{= distance[i] * textureCoordinateRatio }%
                      %{= 0.5 * width * textureCoordinateRatio }% %{= distance[i] * textureCoordinateRatio }%
                    %{ end }%
                  ]
                }
                coordIndex [
                  %{ for i = 0, nbWayPoint - 2 do }%
                    %{= 2 * i }% %{= 2 * (i + 1) }% %{= 1 + 2 * (i + 1) }% -1
                    %{= 2 * i }% %{= 1 + 2 * (i + 1) }% %{= 1 + 2 * i }% -1
                  %{ end }%
                ]
                texCoordIndex [
                  %{ for i = 0, nbWayPoint - 2 do }%
                    %{= 2 * i }% %{= 2 * (i + 1) }% %{= 1 + 2 * (i + 1) }% -1
                    %{= 2 * i }% %{= 1 + 2 * (i + 1) }% %{= 1 + 2 * i }% -1
                  %{ end }%
                ]
                creaseAngle 0.2
              }
              castShadows IS castShadows
            }
          ]
          name "road ground"
          %{ if roadBO then }%
            contactMaterial IS contactMaterial
            boundingObject USE ROAD_GEOMETRY
          %{ end }%
          recognitionColors [ 0.2 0.2 0.2 ]
          model "road"
        }
        # road signs (start)
        %{ for i = 0, nbStartLine - 1 do }%
          # if not same sign than previous lane
          %{ if startLine[i+1] ~= startLine[i] and startLine[i+1] ~= "" then }%
            %{
              local size = 1
              for j = i + 1, nbStartLine - 1 do
                if startLine[i+1] == startLine[j+1] then
                  size = size + 1
                else
                  break
                end
              end
            }%
            Shape {
              appearance PBRAppearance {
                baseColorMap ImageTexture {
                  url [ %{= '"' .. startLine[i+1] .. '"' }% ]
                  filtering 5
                }
                roughness 0.7
                metalness 0
                normalMap ImageTexture {
                  url [
                    "textures/line_normal.jpg"
                  ]
                  filtering 5
                }
                occlusionMap ImageTexture {
                  url [
                    "textures/line_occlusion.jpg"
                  ]
                  filtering 5
                }
              }
              geometry DEF START_ROAD_LINES_GEOMETRY IndexedFaceSet {
                coord Coordinate {
                  point [
                    %{ local heightDiff = 0.4 * (wayPoints[2].y - wayPoints[1].y) /  wbvector2.distance({ x = wayPoints[1].x; y = wayPoints[1].z }, { x = wayPoints[2].x; y = wayPoints[2].z }) }%
                    %{= (i / numberOfLanes - 0.5)          * math.cos(angle[0]) * width + wayPoints[1].x }%                             %{= wayPoints[1].y + (i / numberOfLanes - 0.5)          * math.sin(tilt[1]) * width + heightOffset }%              %{= (i / numberOfLanes - 0.5)          * math.sin(angle[0]) * width + wayPoints[1].z }%
                    %{= ((i + size) / numberOfLanes - 0.5) * math.cos(angle[0]) * width + wayPoints[1].x }%                             %{= wayPoints[1].y + ((i + size) / numberOfLanes - 0.5) * math.sin(tilt[1]) * width + heightOffset }%              %{= ((i + size) / numberOfLanes - 0.5) * math.sin(angle[0]) * width + wayPoints[1].z }%
                    %{= ((i + size) / numberOfLanes - 0.5) * math.cos(angle[0]) * width + wayPoints[1].x + 0.4 * math.sin(-angle[0]) }% %{= wayPoints[1].y + ((i + size) / numberOfLanes - 0.5) * math.sin(tilt[1]) * width + heightOffset + heightDiff }% %{= ((i + size) / numberOfLanes - 0.5) * math.sin(angle[0]) * width + wayPoints[1].z + 0.4 * math.cos(angle[0]) }%
                    %{= (i / numberOfLanes - 0.5)          * math.cos(angle[0]) * width + wayPoints[1].x + 0.4 * math.sin(-angle[0]) }% %{= wayPoints[1].y + (i / numberOfLanes - 0.5)          * math.sin(tilt[1]) * width + heightOffset + heightDiff }% %{= (i / numberOfLanes - 0.5)          * math.sin(angle[0]) * width + wayPoints[1].z + 0.4 * math.cos(angle[0]) }%
                  ]
                }
                texCoord TextureCoordinate {
                  point [
                    0 0
                    %{= size * width / (0.4 * numberOfLanes) }% 0
                    %{= size * width / (0.4 * numberOfLanes) }% 1
                    0 1
                  ]
                }
                coordIndex [
                  0 3 2 1
                ]
                texCoordIndex [
                  0 3 2 1
                ]
                creaseAngle 0.2
              }
              castShadows FALSE
            }
          %{ end }%
        %{ end }%
        # road signs (end)
        %{ for i = 0, nbEndLine - 1 do }%
          # if not same sign than previous lane
          %{ if endLine[i+1] ~= endLine[i] and endLine[i+1] ~= ""  then }%
            %{
              local size = 1
              for j = i + 1, nbEndLine - 1 do
                if endLine[i+1] == endLine[j+1] then
                  size = size + 1
                else
                  break
                end
              end
            }%
            Shape {
              appearance PBRAppearance {
                baseColorMap ImageTexture {
                  url [ %{= '"' .. endLine[i+1] .. '"' }% ]
                  filtering 5
                }
                roughness 0.7
                metalness 0
                normalMap ImageTexture {
                  url [
                    "textures/line_normal.jpg"
                  ]
                  filtering 5
                }
                occlusionMap ImageTexture {
                  url [
                    "textures/line_occlusion.jpg"
                  ]
                  filtering 5
                }
              }
              geometry DEF END_ROAD_LINES_GEOMETRY IndexedFaceSet {
                coord Coordinate {
                  point [
                    %{ local heightDiff = 0.4 * (wayPoints[nbWayPoint-1].y - wayPoints[nbWayPoint].y) /  wbvector2.distance({ x = wayPoints[nbWayPoint-1].x; y = wayPoints[nbWayPoint-1].z }, { x = wayPoints[nbWayPoint].x; y = wayPoints[nbWayPoint].z }) }%
                    %{= (i / numberOfLanes - 0.5)          * math.cos(angle[nbWayPoint-1]) * width + wayPoints[nbWayPoint].x }%                                        %{= wayPoints[nbWayPoint].y + (i / numberOfLanes - 0.5)          * math.sin(tilt[nbWayPoint]) * width + heightOffset }%              %{= (i / numberOfLanes - 0.5)          * math.sin(angle[nbWayPoint-1]) * width + wayPoints[nbWayPoint].z }%
                    %{= ((i + size) / numberOfLanes - 0.5) * math.cos(angle[nbWayPoint-1]) * width + wayPoints[nbWayPoint].x }%                                        %{= wayPoints[nbWayPoint].y + ((i + size) / numberOfLanes - 0.5) * math.sin(tilt[nbWayPoint]) * width + heightOffset }%              %{= ((i + size) / numberOfLanes - 0.5) * math.sin(angle[nbWayPoint-1]) * width + wayPoints[nbWayPoint].z }%
                    %{= ((i + size) / numberOfLanes - 0.5) * math.cos(angle[nbWayPoint-1]) * width + wayPoints[nbWayPoint].x - 0.4 * math.sin(-angle[nbWayPoint-1]) }% %{= wayPoints[nbWayPoint].y + ((i + size) / numberOfLanes - 0.5) * math.sin(tilt[nbWayPoint]) * width + heightOffset + heightDiff }% %{= ((i + size) / numberOfLanes - 0.5) * math.sin(angle[nbWayPoint-1]) * width + wayPoints[nbWayPoint].z - 0.4 * math.cos(angle[nbWayPoint-1]) }%
                    %{= (i / numberOfLanes - 0.5)          * math.cos(angle[nbWayPoint-1]) * width + wayPoints[nbWayPoint].x - 0.4 * math.sin(-angle[nbWayPoint-1]) }% %{= wayPoints[nbWayPoint].y + (i / numberOfLanes - 0.5)          * math.sin(tilt[nbWayPoint]) * width + heightOffset + heightDiff }% %{= (i / numberOfLanes - 0.5)          * math.sin(angle[nbWayPoint-1]) * width + wayPoints[nbWayPoint].z - 0.4 * math.cos(angle[nbWayPoint-1]) }%
                  ]
                }
                texCoord TextureCoordinate {
                  point [
                    0 0
                    %{= size * width / (0.4 * numberOfLanes) }% 0
                    %{= size * width / (0.4 * numberOfLanes) }% 1
                    0 1
                  ]
                }
                coordIndex [
                  0 1 2 3
                ]
                texCoordIndex [
                  0 1 2 3
                ]
                creaseAngle 0.2
              }
              castShadows FALSE
            }
          %{ end }%
        %{ end }%
        # lines
        %{ for j = 1, numberOfLanes - 1 do }%
          %{ if roadLines[j] == nil or (roadLines[j].fields.type.value ~= "none" and roadLines[j].fields.width.value > 0) then }%
            DEF LINES Solid {
              children [
                Shape {
                  appearance PBRAppearance {
                    %{ if roadLines[j] then }%
                      baseColor %{= roadLines[j].fields.color.value.r }% %{= roadLines[j].fields.color.value.g }% %{= roadLines[j].fields.color.value.b }%
                    %{ end }%
                    baseColorMap ImageTexture {
                      url [
                      %{ if (roadLines[j] and (roadLines[j].fields.type.value == "continuous" or roadLines[j].fields.type.value == "double")) or dashedLine[j] == false then }%
                        "textures/line_base_color.png"
                      %{ else }%
                        "textures/line_base_color_dashed.png"
                      %{ end }%
                      ]
                      filtering 5
                    }
                    roughness 0.7
                    metalness 0
                    normalMap ImageTexture {
                      url [
                        "textures/line_normal.jpg"
                      ]
                      filtering 5
                    }
                    occlusionMap ImageTexture {
                      url [
                        "textures/line_occlusion.jpg"
                      ]
                      filtering 5
                    }
                    textureTransform TextureTransform {
                      scale 1 0.2
                    }
                  }
                  geometry IndexedFaceSet {
                    coord Coordinate {
                      point [
                        %{
                          local lineWidth = defaultLineWidth
                          if roadLines[j] then
                            lineWidth = roadLines[j].fields.width.value / 2
                            if roadLines[j].fields.type.value == "double" then
                              lineWidth = lineWidth * 3
                            end
                          end
                        }%
                        %{ for i = 0, nbWayPoint - 1 do }%
                          %{ local offset = width * (j / numberOfLanes - 0.5) }%
                          %{= wayPoints[i+1].x + math.cos(angle[i]) * (offset - lineWidth) }% %{= wayPoints[i+1].y + math.sin(tilt[i+1]) * (offset - lineWidth) + heightOffset }% %{= wayPoints[i+1].z + math.sin(angle[i]) * (offset - lineWidth) }%
                          %{= wayPoints[i+1].x + math.cos(angle[i]) * (offset + lineWidth) }% %{= wayPoints[i+1].y + math.sin(tilt[i+1]) * (offset + lineWidth) + heightOffset }% %{= wayPoints[i+1].z + math.sin(angle[i]) * (offset + lineWidth) }%
                        %{ end }%
                      ]
                    }
                    texCoord TextureCoordinate {
                      point [
                        %{ for i = 0, nbWayPoint - 1 do }%
                          %{= 0 }% %{= distance[i] }%
                          %{ if roadLines[j] and roadLines[j].fields.type.value == "double" then }%
                            %{= 2 }% %{= distance[i] }%
                          %{ else }%
                            %{= 1 }% %{= distance[i] }%
                          %{ end }%
                        %{ end }%
                      ]
                    }
                    coordIndex [
                      %{ for i = 0, nbWayPoint - 2 do }%
                        %{= 2 * i }% %{= 2 * (i + 1) }% %{= 1 + 2 * (i + 1) }% %{= 1 + 2 * i }% -1
                      %{ end }%
                    ]
                    texCoordIndex [
                      %{ for i = 0, nbWayPoint - 2 do }%
                        %{= 2 * i }% %{= 2 * (i + 1) }% %{= 1 + 2 * (i + 1) }% %{= 1 + 2 * i }% -1
                      %{ end }%
                    ]
                    creaseAngle 0.2
                  }
                  castShadows IS castShadows
                }
              ]
              name "road line(%{= j - 1 }%)"
              recognitionColors [ 1 1 1 ]
              model "road line"
            }
          %{ end }%
        %{ end }%
      %{ end }%
      # right border
      %{ if rightBorder then }%
        DEF RIGHT_BORDER Solid {
          children [
            Shape {
              appearance IS pavementAppearance
              geometry DEF RIGHT_BORDER_GEOMETRY IndexedFaceSet {
                coord Coordinate {
                  point [
                    %{ for i = 0, nbWayPoint - 1 do }%
                      %{ if nbBorderWidthPoint > 0 then }%
                        %{= -(width/2 + borderWidth[i+1])  * math.cos(angle[i]) + wayPoints[i+1].x }% %{= wayPoints[i+1].y - math.sin(tilt[i+1]) * width / 2  }%   %{= -(width/2 + borderWidth[i+1]) * math.sin(angle[i]) + wayPoints[i+1].z }% # lower exterior right street border
                        %{= -(width/2 + borderWidth[i+1])  * math.cos(angle[i]) + wayPoints[i+1].x }% %{= borderHeight + wayPoints[i+1].y - math.sin(tilt[i+1]) * width / 2 }%   %{= -(width/2 + borderWidth[i+1]) * math.sin(angle[i]) + wayPoints[i+1].z }% # higher exterior right street border
                      %{ end }%
                      %{= -width/2 * math.cos(angle[i]) + wayPoints[i+1].x }% %{= borderHeight + wayPoints[i+1].y - math.sin(tilt[i+1]) * width / 2 }%   %{= -width/2 * math.sin(angle[i]) + wayPoints[i+1].z }% # higher interior right street border
                      %{= -width/2 * math.cos(angle[i]) + wayPoints[i+1].x }% %{= wayPoints[i+1].y - math.sin(tilt[i+1]) * width / 2 }%   %{= -width/2 * math.sin(angle[i]) + wayPoints[i+1].z }% # lower interior right street border
                    %{ end }%
                  ]
                }
                texCoord TextureCoordinate {
                  point [
                    %{ for i = 0, nbWayPoint - 1 do }%
                      %{ if nbBorderWidthPoint > 0 then }%
                        %{= distance[i] }% %{= 2 * borderHeight + borderWidth[i+1] }%
                        %{= distance[i] }% %{= borderHeight + borderWidth[i+1] }%
                      %{ end }%
                      %{= distance[i] }% %{= borderHeight }%
                      %{= distance[i] }% 0
                    %{ end }%
                  ]
                }
                coordIndex [
                  %{
                    local skip = 2
                    if nbBorderWidthPoint > 0 then
                      skip = 4
                    end
                  }%
                  %{ for i = 0, nbWayPoint - 2 do }%
                    %{ for j = 0, skip - 2 do }%
                      %{= j + skip * i }% %{= j + skip * (i + 1) }% %{= 1 + j + skip * (i + 1) }% %{= 1 + j + skip * i }% -1
                    %{ end }%
                  %{ end }%
                  # close at the start and end
                  %{ if nbBorderWidthPoint > 0 then }%
                    # start
                    0 1 2 3 -1
                    # end
                    %{= nbWayPoint * 4 - 1 }% %{= nbWayPoint * 4 - 2 }% %{= nbWayPoint * 4 - 3 }% %{= nbWayPoint * 4 - 4 }% -1
                  %{ end }%
                ]
                texCoordIndex [
                  %{ for i = 0, nbWayPoint - 2 do }%
                    %{ for j = 0, skip - 2 do }%
                      %{= j + skip * i }% %{= j + skip * (i + 1) }% %{= 1 + j + skip * (i + 1) }% %{= 1 + j + skip * i }% -1
                    %{ end }%
                  %{ end }%
                  # close at the start and end
                  %{ if nbBorderWidthPoint > 0 then }%
                    # start
                    0 1 2 3 -1
                    # end
                    %{= nbWayPoint * 4 - 1 }% %{= nbWayPoint * 4 - 2 }% %{= nbWayPoint * 4 - 3 }% %{= nbWayPoint * 4 - 4 }% -1
                  %{ end }%
                ]
                creaseAngle 0.2
              }
              castShadows IS castShadows
            }
          ]
          name "road right border"
          %{ if rightBorderBO then }%
            contactMaterial IS contactMaterial
            boundingObject USE RIGHT_BORDER_GEOMETRY
          %{ end }%
          recognitionColors [ 0.6 0.6 0.6 ]
          model "road border"
        }
      %{ end }%
      # left border
      %{ if leftBorder then }%
        DEF LEFT_BORDER Solid {
          children [
            Shape {
              appearance IS pavementAppearance
              geometry DEF LEFT_BORDER_GEOMETRY IndexedFaceSet {
                coord Coordinate {
                  point [
                    %{ for i = 0, nbWayPoint - 1 do }%
                      %{ if leftBorder then }%
                        %{=  width/2 * math.cos(angle[i]) + wayPoints[i+1].x }% %{= wayPoints[i+1].y + math.sin(tilt[i+1]) * width / 2 }%   %{= width/2 * math.sin(angle[i]) + wayPoints[i+1].z }% # lower interior left street border
                        %{=  width/2 * math.cos(angle[i]) + wayPoints[i+1].x }% %{= borderHeight + wayPoints[i+1].y + math.sin(tilt[i+1]) * width / 2 }%   %{= width/2 * math.sin(angle[i]) + wayPoints[i+1].z }% # higher interior left street border
                        %{ if nbBorderWidthPoint > 0 then }%
                          %{= (width/2 + borderWidth[i+1])  * math.cos(angle[i]) + wayPoints[i+1].x }% %{= borderHeight + wayPoints[i+1].y + math.sin(tilt[i+1]) * width / 2 }%   %{= (width/2 + borderWidth[i+1]) * math.sin(angle[i]) + wayPoints[i+1].z }% # higher exterior left street border
                          %{= (width/2 + borderWidth[i+1])  * math.cos(angle[i]) + wayPoints[i+1].x }% %{= wayPoints[i+1].y + math.sin(tilt[i+1]) * width / 2 }%   %{= (width/2 + borderWidth[i+1]) * math.sin(angle[i]) + wayPoints[i+1].z }% # lower exterior left street border
                        %{ end }%
                      %{ end }%
                    %{ end }%
                  ]
                }
                texCoord TextureCoordinate {
                  point [
                    %{ for i = 0, nbWayPoint - 1 do }%
                      %{ if nbBorderWidthPoint > 0 then }%
                        %{= distance[i] }% %{= 2 * borderHeight + borderWidth[i+1] }%
                        %{= distance[i] }% %{= borderHeight + borderWidth[i+1] }%
                      %{ end }%
                      %{= distance[i] }% %{= borderHeight }%
                      %{= distance[i] }% 0
                    %{ end }%
                  ]
                }
                coordIndex [
                  %{
                    if nbBorderWidthPoint > 0 then
                      skip = 4
                    else
                      skip = 2
                    end
                  }%
                  %{ for i = 0, nbWayPoint - 2 do }%
                    %{ for j = 0, skip - 2 do }%
                      %{= j + skip * i }% %{= j + skip * (i + 1) }% %{= 1 + j + skip * (i + 1) }% %{= 1 + j + skip * i }% -1
                    %{ end }%
                  %{ end }%
                  # close at the start and end
                  %{ if nbBorderWidthPoint > 0 then }%
                    # start
                    0 1 2 3 -1
                    # end
                    %{= nbWayPoint * 4 - 1 }% %{= nbWayPoint * 4 - 2 }% %{= nbWayPoint * 4 - 3 }% %{= nbWayPoint * 4 - 4 }% -1
                  %{ end }%
                ]
                texCoordIndex [
                  %{ for i = 0, nbWayPoint - 2 do }%
                    %{ for j = 0, skip - 2 do }%
                      %{= j + skip * i }% %{= j + skip * (i + 1) }% %{= 1 + j + skip * (i + 1) }% %{= 1 + j + skip * i }% -1
                    %{ end }%
                  %{ end }%
                  # close at the start and end
                  %{ if nbBorderWidthPoint > 0 then }%
                    # start
                    0 1 2 3 -1
                    # end
                    %{= nbWayPoint * 4 - 1 }% %{= nbWayPoint * 4 - 2 }% %{= nbWayPoint * 4 - 3 }% %{= nbWayPoint * 4 - 4 }% -1
                  %{ end }%
                ]
                creaseAngle 0.2
              }
              castShadows IS castShadows
            }
          ]
          name "road left border"
          %{ if leftBorderBO then }%
            contactMaterial IS contactMaterial
            boundingObject USE LEFT_BORDER_GEOMETRY
          %{ end }%
          recognitionColors [ 0.6 0.6 0.6 ]
          model "road border"
        }
      %{ end }%
      # handle the special bridge case
      %{ if rightBorder and leftBorder and nbBorderWidthPoint == 0 and borderHeight < 0 then }%
        Solid {
          children [
            Shape {
              appearance IS pavementAppearance
              geometry DEF START_END_BORDER_GEOMETRY IndexedFaceSet {
                coord Coordinate {
                  point [
                    %{=  width/2 * math.cos(angle[0]) + wayPoints[1].x }% %{= wayPoints[1].y + math.sin(tilt[1]) * width / 2 }%                  %{=  width/2 * math.sin(angle[0]) + wayPoints[1].z }% # lower interior left street border (start)
                    %{=  width/2 * math.cos(angle[0]) + wayPoints[1].x }% %{= borderHeight + wayPoints[1].y + math.sin(tilt[1]) * width / 2 }%   %{=  width/2 * math.sin(angle[0]) + wayPoints[1].z }% # higher interior left street border (start)
                    %{= -width/2 * math.cos(angle[0]) + wayPoints[1].x }% %{= borderHeight + wayPoints[1].y - math.sin(tilt[1]) * width / 2 }%   %{= -width/2 * math.sin(angle[0]) + wayPoints[1].z }% # higher interior right street border (start)
                    %{= -width/2 * math.cos(angle[0]) + wayPoints[1].x }% %{= wayPoints[1].y - math.sin(tilt[1]) * width / 2 }%                  %{= -width/2 * math.sin(angle[0]) + wayPoints[1].z }% # lower interior right street border (start)
                    %{=  width/2 * math.cos(angle[nbWayPoint-1]) + wayPoints[nbWayPoint].x }% %{= wayPoints[nbWayPoint].y + math.sin(tilt[nbWayPoint]) * width / 2 }%                  %{=  width/2 * math.sin(angle[nbWayPoint-1]) + wayPoints[nbWayPoint].z }% # lower interior left street border (end)
                    %{=  width/2 * math.cos(angle[nbWayPoint-1]) + wayPoints[nbWayPoint].x }% %{= borderHeight + wayPoints[nbWayPoint].y + math.sin(tilt[nbWayPoint]) * width / 2 }%   %{=  width/2 * math.sin(angle[nbWayPoint-1]) + wayPoints[nbWayPoint].z }% # higher interior left street border (end)
                    %{= -width/2 * math.cos(angle[nbWayPoint-1]) + wayPoints[nbWayPoint].x }% %{= borderHeight + wayPoints[nbWayPoint].y - math.sin(tilt[nbWayPoint]) * width / 2 }%   %{= -width/2 * math.sin(angle[nbWayPoint-1]) + wayPoints[nbWayPoint].z }% # higher interior right street border (end)
                    %{= -width/2 * math.cos(angle[nbWayPoint-1]) + wayPoints[nbWayPoint].x }% %{= wayPoints[nbWayPoint].y - math.sin(tilt[nbWayPoint]) * width / 2 }%                  %{= -width/2 * math.sin(angle[nbWayPoint-1]) + wayPoints[nbWayPoint].z }% # lower interior right street border (end)
                  ]
                }
                texCoord TextureCoordinate {
                  point [
                    0                0
                    0            %{= borderHeight }%
                    %{= width }% %{= borderHeight }%
                    %{= width }%     0
                    0                0
                    0            %{= borderHeight }%
                    %{= width }% %{= borderHeight }%
                    %{= width }%     0
                  ]
                }
                coordIndex [
                  0 1 2 3 -1
                  7 6 5 4 -1
                ]
                texCoordIndex [
                  0 1 2 3 -1
                  7 6 5 4 -1
                ]
                creaseAngle 0.2
              }
              castShadows IS castShadows
            }
          ]
          %{ if rightBorderBO and leftBorderBO then }%
            contactMaterial IS contactMaterial
            boundingObject USE START_END_BORDER_GEOMETRY
          %{ end }%
        }
      %{ end }%
      %{ if rightBarrier then }%
        CrashBarrier {
          name "right crash barrier"
          subdivision -1
          enableBoundingObject IS rightBarrierBoundingObject
          barrierOnRightSide FALSE
          path [
          %{ for i = 0, nbWayPoint - 1 do }%
            %{= -(width / 2 + barrierOffset) * math.cos(angle[i]) + wayPoints[i + 1].x }% %{= wayPoints[i + 1].y - math.sin(tilt[i + 1]) * (width / 2 + barrierOffset) }% %{= -(width / 2 + barrierOffset) * math.sin(angle[i]) + wayPoints[i + 1].z }%
          %{ end }%
          ]
        }
      %{ end }%
      %{ if leftBarrier then }%
        CrashBarrier {
          name "left crash barrier"
          subdivision -1
          enableBoundingObject IS leftBarrierBoundingObject
          barrierOnRightSide TRUE
          path [
          %{ for i = 0, nbWayPoint - 1 do }%
            %{= (width / 2 + barrierOffset) * math.cos(angle[i]) + wayPoints[i + 1].x }% %{= wayPoints[i + 1].y + math.sin(tilt[i + 1]) * (width / 2 + barrierOffset) }% %{= (width / 2 + barrierOffset) * math.sin(angle[i]) + wayPoints[i + 1].z }%
          %{ end }%
          ]
        }
      %{ end }%
      # bottom
      %{ if bottom then }%
        Shape {
          appearance PBRAppearance {
            baseColorMap ImageTexture {
              url IS bottomTexture
              filtering 5
            }
            roughness 0.8
            metalness 0
          }
          geometry DEF BOTTOM_GEOMETRY IndexedFaceSet {
            coord Coordinate {
              point [
                %{
                  local leftHeightOffset = 0.0
                  local rightHeightOffset = 0.0
                  if leftBorder and nbBorderWidthPoint == 0 and borderHeight < 0 then
                    leftHeightOffset = borderHeight
                  end
                  if rightBorder and nbBorderWidthPoint == 0 and borderHeight < 0 then
                    rightHeightOffset = borderHeight
                  end
                }%
                %{ for i = 0, nbWayPoint - 1 do }%
                  %{ if leftBorder and nbBorderWidthPoint > 0 then }%
                    %{= (width/2 + borderWidth[i+1]) * math.cos(angle[i]) + wayPoints[i+1].x }% %{= wayPoints[i+1].y + math.sin(tilt[i+1]) * width / 2 }% %{= (width/2 + borderWidth[i+1]) * math.sin(angle[i]) + wayPoints[i+1].z }%
                  %{ else }%
                    %{= width/2 * math.cos(angle[i]) + wayPoints[i+1].x }% %{= wayPoints[i+1].y + math.sin(tilt[i+1]) * width / 2 + leftHeightOffset }% %{= width/2 * math.sin(angle[i]) + wayPoints[i+1].z }%
                  %{ end }%
                  %{ if rightBorder and nbBorderWidthPoint > 0 then }%
                    %{= -(width/2 + borderWidth[i+1]) * math.cos(angle[i]) + wayPoints[i+1].x }% %{= wayPoints[i+1].y - math.sin(tilt[i+1]) * width / 2 }% %{= -(width/2 + borderWidth[i+1]) * math.sin(angle[i]) + wayPoints[i+1].z }%
                  %{ else }%
                    %{= -width/2 * math.cos(angle[i]) + wayPoints[i+1].x }% %{= wayPoints[i+1].y - math.sin(tilt[i+1]) * width / 2 + rightHeightOffset }% %{= -width/2 * math.sin(angle[i]) + wayPoints[i+1].z }%
                  %{ end }%
                %{ end }%
              ]
            }
            %{ if useBottomTexture then }%
              texCoord TextureCoordinate {
                point [
                  %{ for i = 0, nbWayPoint - 1 do }%
                    %{
                      local bottomWidth = width
                      if leftBorder and nbBorderWidthPoint > 0 then
                        bottomWidth = bottomWidth + borderWidth[i+1]
                      end
                      if rightBorder and nbBorderWidthPoint > 0 then
                        bottomWidth = bottomWidth + borderWidth[i+1]
                      end
                    }%
                    %{= distance[i] }%     0
                    %{= distance[i] }% %{= bottomWidth }%
                  %{ end }%
                ]
              }
            %{ end }%
            coordIndex [
              %{  skip = 2 }%
              %{ for i = 0, nbWayPoint - 2 do }%
                %{= skip * i }% %{= skip * (i + 1) }% %{= 1 + skip * (i + 1) }% %{= 1 + skip * i }% -1
              %{ end }%
            ]
            %{ if useBottomTexture then }%
              texCoordIndex [
                %{  skip = 2 }%
                %{ for i = 0, nbWayPoint - 2 do }%
                  %{= skip * i }% %{= skip * (i + 1) }% %{= 1 + skip * (i + 1) }% %{= 1 + skip * i }% -1
                %{ end }%
              ]
            %{ end }%
            creaseAngle 0.2
          }
          castShadows IS castShadows
        }
      %{ end }%
      # turn lanes (forward)
      %{ if nbWayPoint > 2 and fields.turnLanesForward.value ~= '' then }%
        Transform {
          translation %{= wayPoints[nbWayPoint].x }% %{= wayPoints[nbWayPoint].y + heightOffset }% %{= wayPoints[nbWayPoint].z }%
          rotation 0 1 0 %{= math.pi - angle[nbWayPoint - 1] }%
          children [
          %{
            local turnLanes = wbstring.split(fields.turnLanesForward.value, '|')
            local nTurnLanes = wbcore.tablelength(turnLanes)
          }%
          %{ for i,turnLane in ipairs(turnLanes) do }%
            Transform {
              translation %{= ((i - nTurnLanes - 1.0) / numberOfLanes + 0.5) * width }% 0 4
              children [
                Shape {
                  appearance PBRAppearance {
                    baseColorMap ImageTexture {
                      url [
                        "textures/painted_arrows.png"
                      ]
                      filtering 5
                    }
                    roughness 0.7
                    metalness 0
                    normalMap ImageTexture {
                      url [
                        "textures/line_normal.jpg"
                      ]
                      filtering 5
                    }
                    occlusionMap ImageTexture {
                      url [
                        "textures/line_occlusion.jpg"
                      ]
                      filtering 5
                    }
                    textureTransform TextureTransform {
                      %{
                        local through = string.match(turnLane, "through")
                        local left = string.match(turnLane, "left")
                        local right = string.match(turnLane, "right")

                        local trX = 0
                        if left then
                          trX = trX + 1
                        end
                        if right then
                          trX = trX + 2
                        end
                        local trY = through and 1 or 0
                      }%
                      scale 0.25 0.5
                      translation %{= trX }% %{= trY }%
                    }
                  }
                  geometry Plane {
                    size 1 4
                  }
                  castShadows FALSE
                }
              ]
            }
          %{ end }%
          ]
        }
      %{ end }%
      # turn lanes (backward)
      %{ if nbWayPoint > 2 and fields.turnLanesBackward.value ~= '' then }%
        Transform {
          translation %{= wayPoints[1].x }% %{= wayPoints[1].y + heightOffset }% %{= wayPoints[1].z }%
          rotation 0 1 0 %{= - angle[2] }%
          children [
          %{
            local turnLanes = wbstring.split(fields.turnLanesBackward.value, '|')
            local nTurnLanes = wbcore.tablelength(turnLanes)
          }%
          %{ for i,turnLane in ipairs(turnLanes) do }%
            Transform {
              translation %{= ((i - nTurnLanes - 1.0) / numberOfLanes + 0.5) * width }% 0 4
              children [
                Shape {
                  appearance PBRAppearance {
                    baseColorMap ImageTexture {
                      url [
                        "textures/painted_arrows.png"
                      ]
                      filtering 5
                    }
                    roughness 0.7
                    metalness 0
                    normalMap ImageTexture {
                      url [
                        "textures/line_normal.jpg"
                      ]
                      filtering 5
                    }
                    occlusionMap ImageTexture {
                      url [
                        "textures/line_occlusion.jpg"
                      ]
                      filtering 5
                    }
                    textureTransform TextureTransform {
                      %{
                        local through = string.match(turnLane, "through")
                        local left = string.match(turnLane, "left")
                        local right = string.match(turnLane, "right")

                        local trX = 0
                        if left then
                          trX = trX + 1
                        end
                        if right then
                          trX = trX + 2
                        end
                        local trY = through and 1 or 0
                      }%
                      scale 0.25 0.5
                      translation %{= trX }% %{= trY }%
                    }
                  }
                  geometry Plane {
                    size 1 4
                  }
                  castShadows FALSE
                }
              ]
            }
          %{ end }%
          ]
        }
      %{ end }%
    ]
    locked IS locked
  }
}
